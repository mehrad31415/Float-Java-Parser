# Float-Java-Parser
<dl>
<dt>This is a small parser (in Haskell) for Java Floating point numbers.</dt>

<dt>The following steps have been taken:</dt>

#### 1
<dd>Example *sentences* of the "Floating Point Numbers" *language* in Java are:


    1.2 , 1. , 0.23 , .42 , 0.42F , 0.3f , 12.4D , 199.3d , etc.
    

#### 2
This is the *grammar* of Floating point numbers in Java. However, this is not the only solution and many grammars can lead to the same language.
In other words, the mapping between *grammars* and *languages* is not injection (1-1). 

```
FloatLiteral -> IntPart Z
			  | . FractPart ExponentPart? FloatSuffix?

-- left factoring.
Z -> . FractPart? ExponentPart? FloatSuffix?
   | ExponentPart? FloatSuffix?

IntPart           -> Sign? Digits
FractPart         -> Digits
ExponentPart      -> ExponentIndicator IntPart
-- not left recursive
Digits 		  -> Digit<sup>+</sup>
ExponentIndicator -> e | E
Sign              -> + | -
FloatSuffix       -> f | F | d | D
Digit 		  -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
```
##### 3
Grammar Properties: First, we check if the generated grammar has the following features: Is the grammar *sound*; in other words, are all sentences generated by the grammar a floating point number? Is the grammary *complete*; i.e., are all floating point numbers included in the grammar?
We observe that the grammary is both sound and complete.

Furthermore, the generated grammar is left-factored (making the parsing more efficient), is not left-recursive, and is not ambiguous.

#### 4
The parser type for floating point numbers will be *Parser Char FloatLiteral* where *FloatLiteral* is a self created data type. We further write the parser and the semantic functions by using our algebric data types.
	</dd>
</dl>
